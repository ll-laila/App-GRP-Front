declare abstract class BaseValidator<T> {
    private validatorItem;
    protected constructor(validatorItem: ValidatorItem<T>);
    protected get value(): T | undefined;
    protected error(msg: string): void;
    valid(): void;
    abstract errorIf(errorCondition: boolean, errorMsg: string): BaseValidator<T> | undefined;
    protected baseCondition<V extends BaseValidator<T>>(errorCondition: boolean, errorMsg: string, validator: V): V | undefined;
}

declare class AnyValidators extends BaseValidator<any> {
    constructor(validatorItem: ValidatorItem<any>);
    required(errorMsg?: string | undefined): AnyValidators | undefined;
    errorIf(errorCondition: boolean, errorMsg: string): AnyValidators | undefined;
}

declare class NumberValidator extends BaseValidator<number> {
    constructor(validatorItem: ValidatorItem<number>);
    required(errorMsg?: string | undefined): NumberValidator | undefined;
    gt(value: number, errorMsg?: string | undefined): NumberValidator | undefined;
    gte(value: number, errorMsg?: string | undefined): NumberValidator | undefined;
    lt(value: number, errorMsg?: string | undefined): NumberValidator | undefined;
    lte(value: number, errorMsg?: string | undefined): NumberValidator | undefined;
    multipleOf(value: number, errorMsg?: string | undefined): NumberValidator | undefined;
    safe(errorMsg?: string | undefined): NumberValidator | undefined;
    positive(errorMsg?: string | undefined): NumberValidator | undefined;
    negative(errorMsg?: string | undefined): NumberValidator | undefined;
    errorIf(errorCondition: boolean, errorMsg: string): NumberValidator | undefined;
}

declare class StringValidator extends BaseValidator<string> {
    constructor(validatorItem: ValidatorItem<string>);
    required(errorMsg?: string | undefined): StringValidator | undefined;
    max(max: number, errorMsg?: string | undefined): StringValidator | undefined;
    min(min: number, errorMsg?: string | undefined): StringValidator | undefined;
    length(length: number, errorMsg?: string | undefined): StringValidator | undefined;
    includes(sub: string, errorMsg?: string | undefined): StringValidator | undefined;
    startsWith(start: string, errorMsg?: string | undefined): StringValidator | undefined;
    endsWith(start: string, errorMsg?: string | undefined): StringValidator | undefined;
    email(errorMsg?: string | undefined): StringValidator | undefined;
    phone(errorMsg?: string | undefined): StringValidator | undefined;
    pattern(pattern: RegExp, errorMsg: string): StringValidator | undefined;
    errorIf(errorCondition: boolean, errorMsg: string): StringValidator | undefined;
}

declare class ValidatorsCollector {
    protected value: any | undefined;
    private _validators;
    get validators(): AnyValidators;
    private _stringValidators;
    get stringValidators(): StringValidator;
    private _numberValidators;
    get numberValidators(): NumberValidator | undefined;
    private checkType;
    private typeError;
}

type index_AnyValidators = AnyValidators;
declare const index_AnyValidators: typeof AnyValidators;
type index_BaseValidator<T> = BaseValidator<T>;
declare const index_BaseValidator: typeof BaseValidator;
type index_NumberValidator = NumberValidator;
declare const index_NumberValidator: typeof NumberValidator;
type index_StringValidator = StringValidator;
declare const index_StringValidator: typeof StringValidator;
type index_ValidatorsCollector = ValidatorsCollector;
declare const index_ValidatorsCollector: typeof ValidatorsCollector;
declare namespace index {
  export { index_AnyValidators as AnyValidators, index_BaseValidator as BaseValidator, index_NumberValidator as NumberValidator, index_StringValidator as StringValidator, index_ValidatorsCollector as ValidatorsCollector };
}

declare class ValidatorItem<T> extends ValidatorsCollector {
    constructor(field: () => T | undefined, setter: ((value: T | undefined) => void), validation?: ((value: T | undefined) => void) | undefined);
    valid: boolean | undefined;
    message: string | undefined;
    field: () => T | undefined;
    setter: (value: T | undefined) => void;
    validate(): void;
    validations: (value: T | undefined) => void;
    reset(): void;
    error(msg: string): void;
}

declare class ValidatorResult<T> {
    field: string;
    value: T;
    valid: boolean;
    message: string;
}

type NestedValidator = {
    name: string;
    validator: Validator<any>;
};
declare abstract class Validator<T> {
    item: () => T;
    nestedValidators: NestedValidator[] | undefined;
    abstract validatorItems: ValidatorItem<any>[];
    getValidatorItems(): ValidatorItem<any>[];
    get allGood(): boolean | undefined;
    applyAll(): void;
    reset(): void;
    validate(): boolean;
    protected nested(name: string, validator: Validator<any>): void;
    abstract getValidatorItem(fieldName: string): ValidatorItem<any>;
    import(results: ValidatorResult<any>[]): void;
}

declare const EMAIL_PATTERN: RegExp;
declare const PHONE_PATTERN: RegExp;

declare const validatorUtils_EMAIL_PATTERN: typeof EMAIL_PATTERN;
declare const validatorUtils_PHONE_PATTERN: typeof PHONE_PATTERN;
declare namespace validatorUtils {
  export { validatorUtils_EMAIL_PATTERN as EMAIL_PATTERN, validatorUtils_PHONE_PATTERN as PHONE_PATTERN };
}

export { Validator, ValidatorItem, index as ValidatorMethods, ValidatorResult, validatorUtils as ValidatorUtils };
